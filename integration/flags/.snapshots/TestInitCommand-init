policy:
    only-policy: []
    skip-policy: []
report:
    format: ""
    output: ""
    report: detectors
scan:
    context: ""
    custom_detector:
        detect_encrypted_ruby_class_properties:
            disabled: false
            type: verifier
            languages:
                - ruby
            param_parenting: true
            processors: []
            patterns:
                - pattern: |
                    class $CLASS_NAME < ApplicationRecord
                      encrypts <$ARGUMENT>
                    end
                  filters: []
            root_singularize: true
            root_lowercase: true
            metavars: {}
            stored: false
            detect_presence: false
        detect_rails_insecure_communication:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    Rails.application.configure do
                      config.force_ssl = false
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
        detect_rails_insecure_ftp:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    Net::FTP::new
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
        detect_rails_insecure_smtp:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    Rails.application.configure do
                      config.action_mailer.smtp_settings = {
                        openssl_verify_mode: OpenSSL::SSL::VERIFY_NONE
                      }
                    end
                  filters: []
                - pattern: |
                    Rails.application.configure do
                      config.action_mailer.smtp_settings = {
                        openssl_verify_mode: "none"
                      }
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
        detect_rails_jwt:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    JWT.encode(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
        detect_rails_session:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    session[...] = $ANYTHING
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
        detect_ruby_logger:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    logger.info(<$ARGUMENT>)
                  filters: []
                - pattern: |
                    Rails.logger.info(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
        detect_sql_create_public_table:
            disabled: false
            type: data_type
            languages:
                - sql
            param_parenting: true
            processors:
                - query: |
                    verified_by = data.bearer.encrypted_verified.verified_by
                    encrypted = data.bearer.encrypted_verified.encrypted
                  modules:
                    - name: bearer.encrypted_verified
                      content: |-
                        package bearer.encrypted_verified

                        import future.keywords


                        default encrypted := false


                        ruby_encrypted[location] {
                            some detection in input.all_detections
                            detection.detector_type == "detect_encrypted_ruby_class_properties"
                            detection.value.classification.decision.state == "valid"
                            location = detection
                        }

                        encrypted = true {
                            some detection in ruby_encrypted
                            detection.value.object_name == input.target.value.object_name
                            detection.value.field_name == input.target.value.field_name
                            input.target.value.field_name != ""
                            input.target.value.object_name != ""
                        }

                        verified_by[verification] {
                            some detection in ruby_encrypted
                            detection.value.object_name == input.target.value.object_name
                            detection.value.field_name == input.target.value.field_name

                            verification = {
                                "detector": "detect_encrypted_ruby_class_properties",
                                "filename": detection.source.filename,
                                "line_number": detection.source.line_number
                            }
                        }
            patterns:
                - pattern: |
                    CREATE TABLE public.$TABLE_NAME (
                      <$COLUMN>
                    )
                  filters: []
            root_singularize: true
            root_lowercase: true
            metavars: {}
            stored: false
            detect_presence: false
        ruby_file_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: true
            processors: []
            patterns:
                - pattern: |
                    CSV.open { <$DATA_TYPE> }
                  filters: []
                - pattern: |
                    CSV.open do
                      <$DATA_TYPE>
                    end
                  filters: []
                - pattern: |
                    File.open do
                      <$DATA_TYPE>
                    end
                  filters: []
                - pattern: |
                    File.open { <$DATA_TYPE> }
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
        ruby_http_get_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    URI.encode_www_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    URI(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    $CLIENT.get(<$DATA_TYPE>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
        ruby_http_post_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    URI.encode_www_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    Net::HTTP.post_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    $CLIENT.post(<$DATA_TYPE>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
        ssl_certificate_verification_disabled:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            processors: []
            patterns:
                - pattern: |
                    $_.verify_mode = OpenSSL::SSL::VERIFY_NONE
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
    debug: false
    disable-domain-resolution: true
    domain-resolution-timeout: 3s
    internal-domains: []
    policies:
        application_level_encryption_missing:
            query: |
                critical = data.bearer.application_level_encryption.critical
                high = data.bearer.application_level_encryption.high
            id: detect_sql_create_public_table
            name: Application level encryption missing
            description: Application level encryption missing
            level: ""
            modules:
                - path: policies/application_level_encryption.rego
                  name: bearer.application_level_encryption
                  content: "package bearer.application_level_encryption\n\nimport future.keywords\n\nsensitive_data_group_uuid := \"f6a0c071-5908-4420-bac2-bba28d41223e\"\npersonal_data_group_uuid := \"e1d3135b-3c0f-4b55-abce-19f27a26cbb3\"\n\nhigh[item] {\n    some datatype in input.dataflow.data_types    \n    some detector in datatype.detectors\n    detector.name == input.policy_id\n    \n    some location in detector.locations\n    not location.encrypted\n\n    some category in input.data_categories\n    category.uuid == datatype.category_uuid\n    category.group_uuid == sensitive_data_group_uuid\n\n    item = {\n        \"category_group\":  category.group_name,\n        \"filename\": location.filename,\n        \"line_number\": location.line_number,\n        \"parent_line_number\": detector.parent.line_number,\n        \"parent_content\": detector.parent.content\n\n    }\n}\n\ncritical[item] {\n    some datatype in input.dataflow.data_types    \n    some detector in datatype.detectors\n    detector.name == input.policy_id\n    \n    some location in detector.locations\n    not location.encrypted\n\n    some category in input.data_categories\n    category.uuid == datatype.category_uuid\n    category.group_uuid == personal_data_group_uuid\n\n    item = {\n        \"category_group\":  category.group_name,\n        \"filename\": location.filename,\n        \"line_number\": location.line_number,\n        \"parent_line_number\": detector.parent.line_number,\n        \"parent_content\": detector.parent.content\n    }\n}"
        http_get_parameters:
            query: |
                critical = data.bearer.http_get_parameters.critical
                high = data.bearer.http_get_parameters.high
            id: ruby_http_get_detection
            name: HTTP GET parameters
            description: Sending data as HTTP GET parameters
            level: ""
            modules:
                - path: policies/http_get_parameters.rego
                  name: bearer.http_get_parameters
                  content: |
                    package bearer.http_get_parameters

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    item_in_data_category contains [category_group_uuid, item] if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category_group_uuid := category.group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    high[item] {
                        item_in_data_category[[sensitive_data_group_uuid, item]]
                    }

                    critical[item] {
                        item_in_data_category[[personal_data_group_uuid, item]]
                    }
        insecure_communication_processing_sensitive_data:
            query: |
                medium = data.bearer.insecure_communication.medium
            id: detect_rails_insecure_communication
            name: Insecure communication
            description: Insecure communication in an application processing sensitive data
            level: ""
            modules:
                - path: policies/insecure_communication.rego
                  name: bearer.insecure_communication
                  content: |
                    package bearer.insecure_communication

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"

                    medium[item] {
                        some data_type in input.dataflow.data_types
                        some data_category in input.data_categories
                        data_category.uuid == data_type.category_uuid
                        data_category.group_uuid == sensitive_data_group_uuid

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                          "category_group": data_category.group_name,
                          "filename": location.filename,
                          "line_number": location.line_number,
                          "parent_line_number": location.parent.line_number,
                          "parent_content": location.parent.content
                        }
                    }
        insecure_ftp_processing_sensitive_data:
            query: |
                medium = data.bearer.insecure_ftp.medium
            id: detect_rails_insecure_ftp
            name: Insecure FTP
            description: Communication with insecure FTP in an application processing sensitive data
            level: ""
            modules:
                - path: policies/insecure_ftp.rego
                  name: bearer.insecure_ftp
                  content: |
                    package bearer.insecure_ftp

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"

                    has_sensitive_data if {
                        some data_type in input.dataflow.data_types
                        some data_category in input.data_categories
                        data_category.uuid == data_type.category_uuid
                        data_category.group_uuid == sensitive_data_group_uuid
                    }

                    medium[item] {
                        has_sensitive_data == true

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                             "category_group": "sensitive data",
                             "filename": location.filename,
                             "line_number": location.line_number,
                             "parent_line_number": location.parent.line_number,
                             "parent_content": location.parent.content
                        }
                    }
        insecure_smtp_processing_sensitive_data:
            query: |
                medium = data.bearer.insecure_smtp.medium
            id: detect_rails_insecure_smtp
            name: Insecure SMTP
            description: Communication with insecure SMTP in an application processing sensitive data
            level: ""
            modules:
                - path: policies/insecure_smtp.rego
                  name: bearer.insecure_smtp
                  content: |
                    package bearer.insecure_smtp

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"

                    medium[item] {
                        some data_type in input.dataflow.data_types
                        some data_category in input.data_categories
                        data_category.uuid == data_type.category_uuid
                        data_category.group_uuid == sensitive_data_group_uuid

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                            "category_group": data_category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        jwt_leaks:
            query: |
                critical = data.bearer.leakage.critical
                high = data.bearer.leakage.high
            id: detect_rails_jwt
            name: JWT leaking
            description: JWT leaks detected
            level: ""
            modules:
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    high[item] {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category.group_uuid == sensitive_data_group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    critical[item] {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category.group_uuid == personal_data_group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        logger_leaks:
            query: |
                critical = data.bearer.leakage.critical
                high = data.bearer.leakage.high
            id: detect_ruby_logger
            name: Logger leaking
            description: Logger leaks detected
            level: ""
            modules:
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    high[item] {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category.group_uuid == sensitive_data_group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    critical[item] {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category.group_uuid == personal_data_group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        session_leaks:
            query: |
                critical = data.bearer.leakage.critical
                high = data.bearer.leakage.high
            id: detect_rails_session
            name: Session leaking
            description: Session leaks detected
            level: ""
            modules:
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    high[item] {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category.group_uuid == sensitive_data_group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    critical[item] {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        some category in input.data_categories
                        category.uuid == data_type.category_uuid
                        category.group_uuid == personal_data_group_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_group": category.group_name,
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        ssl_certificate_verification_disabled:
            query: |
                medium = data.bearer.ssl_certificate_verification_disabled.medium
            id: ssl_certificate_verification_disabled
            name: SSL certificate verification disabled
            description: SSL certificate verification disabled in an application processing sensitive data
            level: ""
            modules:
                - path: policies/ssl_certificate_verification_disabled.rego
                  name: bearer.ssl_certificate_verification_disabled
                  content: |
                    package bearer.ssl_certificate_verification_disabled

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"

                    medium[item] {
                      some data_type in input.dataflow.data_types

                      some category in input.data_categories
                      category.uuid == data_type.category_uuid
                      category.group_uuid == sensitive_data_group_uuid

                      some detector in input.dataflow.risks
                      detector.detector_id == input.policy_id
                      location = detector.locations[_]

                      item = {
                        "category_group": category.group_name,
                        "filename": location.filename,
                        "line_number": location.line_number,
                        "parent_line_number": location.parent.line_number,
                        "parent_content": location.parent.content
                      }
                    }
    quiet: false
    skip-path: []
worker:
    existing-worker: ""
    file-size-max: 100000
    files-to-batch: 1
    memory-max: 800000000
    timeout: 10m0s
    timeout-file-max: 30s
    timeout-file-min: 5s
    timeout-file-second-per-bytes: 10000
    timeout-worker-online: 1m0s
    workers: 1

