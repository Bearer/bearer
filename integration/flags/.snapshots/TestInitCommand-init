policy:
    only-policy: []
    skip-policy: []
report:
    format: ""
    output: ""
    report: policies
scan:
    context: ""
    custom_detector:
        detect_encrypted_ruby_class_properties:
            disabled: false
            type: verifier
            languages:
                - ruby
            param_parenting: true
            patterns:
                - pattern: |
                    class $CLASS_NAME < ApplicationRecord
                      encrypts <$ARGUMENT>
                    end
                  filters: []
            root_singularize: true
            root_lowercase: true
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_cookies:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    cookies[...] = $ANYTHING
                  filters: []
                - pattern: |
                    cookies.$METHOD_CHAIN[...] = $ANYTHING
                  filters:
                    - variable: METHOD_CHAIN
                      values:
                        - permanent
                        - encrypted
                        - signed
                        - permanent.encrypted
                        - permanent.signed
                        - permanent.encrypted.signed
                        - permanent.signed.encrypted
                        - encrypted.permanent
                        - encrypted.signed
                        - encrypted.permanent.signed
                        - encrypted.signed.permanent
                        - signed.encrypted
                        - signed.permanent
                        - signed.permanent.encrypted
                        - signed.encrypted.permanent
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_insecure_communication:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Rails.application.configure do
                      config.force_ssl = false
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: true
        detect_rails_insecure_ftp:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::FTP.new()
                  filters: []
                - pattern: |
                    Net::FTP.open()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        detect_rails_insecure_ftp_data:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::FTP.open do
                      $ANYTHING
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_insecure_smtp:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Rails.application.configure do
                      config.action_mailer.smtp_settings = {
                        openssl_verify_mode: OpenSSL::SSL::VERIFY_NONE
                      }
                    end
                  filters: []
                - pattern: |
                    Rails.application.configure do
                      config.action_mailer.smtp_settings = {
                        openssl_verify_mode: "none"
                      }
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: true
        detect_rails_jwt:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    JWT.encode(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_session:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    session[...] = $ANYTHING
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_ruby_logger:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    logger.info(<$ARGUMENT>)
                  filters: []
                - pattern: |
                    Rails.logger.info(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_ruby_third_party_data_send:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Sentry::Breadcrumb.new(<$ARGUMENT>)
                  filters: []
                - pattern: |
                    Sentry.init do |config|
                      config.before_breadcrumb = lambda do |breadcrumb, hint|
                        breadcrumb.message = $ANYTHING
                        breadcrumb
                      end
                    end
                  filters: []
                - pattern: |
                    Sentry.set_user(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_ruby_weak_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Digest::SHA1.hexidigest(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    Digest::MD5.hexdigest(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    OpenSSL::PKey::$LIBRARY.new($_, <$DATA_TYPE>)
                  filters:
                    - variable: LIBRARY
                      values: []
                    - variable: ""
                      values:
                        - DSA
                        - RSA
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_sql_create_public_table:
            disabled: false
            type: data_type
            languages:
                - sql
            param_parenting: true
            patterns:
                - pattern: |
                    CREATE TABLE public.$TABLE_NAME (
                      <$COLUMN>
                    )
                  filters: []
                - pattern: |
                    CREATE TABLE $TABLE_NAME (
                      <$COLUMN>
                    )
                  filters: []
            root_singularize: true
            root_lowercase: true
            metavars: {}
            stored: true
            detect_presence: false
            omit_parent: false
        encrypt_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - encrypt
                        - encrypt!
                        - decrypt
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        initialize_ruby_blowfish_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = Crypt::Blowfish.new(...)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        initialize_ruby_openssl_pkey_dsa_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = OpenSSL::PKey::DSA.new()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        initialize_ruby_openssl_pkey_rsa_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = OpenSSL::PKey::RSA.new()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        initialize_ruby_rc4_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = RC4.new()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ruby_blowfish_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - encrypt_pair
                        - encrypt_string
                        - encrypt_block
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_file_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: true
            patterns:
                - pattern: |
                    CSV.generate { <$DATA_TYPE> }
                  filters: []
                - pattern: |
                    CSV.generate do
                      <$DATA_TYPE>
                    end
                  filters: []
                - pattern: |
                    $LIBRARY.open do
                      <$DATA_TYPE>
                    end
                  filters:
                    - variable: LIBRARY
                      values:
                        - CSV
                        - File
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_http_get_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    URI.encode_www_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    URI(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    $CLIENT.get(<$DATA_TYPE>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_http_get_insecure:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    URI(<$INSECURE_URL>)
                  filters: []
                - pattern: |
                    $CLIENT.get(<$INSECURE_URL>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ruby_http_post_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    URI.encode_www_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    Net::HTTP.post_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    $CLIENT.post(<$DATA_TYPE>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_http_post_insecure:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::HTTP.post_form(<$INSECURE_URL>)
                  filters: []
                - pattern: |
                    $CLIENT.post(<$INSECURE_URL>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ruby_openssl_pkey_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - export
                        - to_pem
                        - to_s
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_openssl_pkey_rsa_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - private_decrypt
                        - private_encrypt
                        - public_decrypt
                        - public_encrypt
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ssl_certificate_verification_disabled:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::HTTP.start($_, $_, $_, :verify_mode => OpenSSL::SSL::VERIFY_NONE) do
                    end
                  filters: []
                - pattern: |
                    $_.verify_mode = OpenSSL::SSL::VERIFY_NONE
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
    debug: false
    disable-domain-resolution: true
    domain-resolution-timeout: 3s
    internal-domains: []
    policies:
        application_level_encryption_missing:
            query: |
                policy_failure = data.bearer.application_level_encryption.policy_failure
            id: application_level_encryption_missing
            name: Application level encryption missing
            description: Application level encryption missing. Enable application level encryption to reduce the risk of leaking sensitive data.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/application_level_encryption.rego
                  name: bearer.application_level_encryption
                  content: |-
                    package bearer.application_level_encryption

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        datatype = input.dataflow.data_types[_]
                        detector = datatype.detectors[_]
                        location = detector.locations[_]

                        location.stored
                        not location.encrypted

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(datatype),
                            "severity": data.bearer.common.severity_of_datatype(datatype),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        cookie_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_rails_cookies
            name: Cookie leaking
            description: Cookie leaks detected. Avoid storing sensitive data in cookies.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        http_get_parameters:
            query: |
                policy_failure = data.bearer.http_get_parameters.policy_failure
            id: ruby_http_get_detection
            name: HTTP GET parameters
            description: Sending data as HTTP GET parameters. Avoid sending sensitive data as parameters in GET requests.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/http_get_parameters.rego
                  name: bearer.http_get_parameters
                  content: |-
                    package bearer.http_get_parameters

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_communication_processing_sensitive_data:
            query: |
                policy_failure = data.bearer.insecure_communication.policy_failure
            id: detect_rails_insecure_communication
            name: Insecure communication
            description: Insecure communication in an application processing sensitive data. Ensure communication occurs over SSL.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_communication.rego
                  name: bearer.insecure_communication
                  content: |
                    package bearer.insecure_communication

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                          "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                          "severity": "medium",
                          "filename": location.filename,
                          "line_number": location.line_number,
                          "omit_parent": true,
                          "parent_line_number": location.parent.line_number,
                          "parent_content": location.parent.content,
                        }
                    }
        insecure_ftp_processing_sensitive_data:
            query: |
                policy_failure = data.bearer.insecure_ftp.policy_failure
            id: detect_rails_insecure_ftp
            name: Insecure FTP
            description: Communication with an insecure FTP server in an application processing sensitive data. Only connect to FTP securely.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_ftp.rego
                  name: bearer.insecure_ftp
                  content: |
                    package bearer.insecure_ftp

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_ftp_with_data_category:
            query: |
                policy_failure = data.bearer.insecure_ftp_with_data_category.policy_failure
            id: insecure_ftp_with_data_category
            name: Insecure FTP with Data Category
            description: Communicating Data Category with an insecure FTP server. Only connect to FTP securely.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_ftp_with_data_category.rego
                  name: bearer.insecure_ftp_with_data_category
                  content: |
                    package bearer.insecure_ftp_with_data_category

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some risk in input.dataflow.risks
                        risk.detector_id == "detect_rails_insecure_ftp_data"

                        data_type = risk.data_types[_]
                        location = data_type.locations[_]

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_http_get:
            query: |
                policy_failure = data.bearer.insecure_http_get.policy_failure
            id: insecure_http_get
            name: Insecure HTTP GET
            description: Communicating using insecure HTTP GET in an application processing sensitive data. Ensure all HTTP communication occurs over HTTPS.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_http_get.rego
                  name: bearer.insecure_http_get
                  content: |
                    package bearer.insecure_http_get

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == "ruby_http_get_insecure"

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_http_with_data_category:
            query: |
                policy_failure = data.bearer.insecure_http_with_data_category.policy_failure
            id: insecure_http_with_data_category
            name: Insecure HTTP with Data Category
            description: Communicating Data Category using insecure HTTP. Ensure all HTTP communication occurs over HTTPS.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_http_with_data_category.rego
                  name: bearer.insecure_http_with_data_category
                  content: |
                    package bearer.insecure_http_with_data_category

                    import data.bearer.common

                    import future.keywords

                    insecure_http_with_data contains [data_detector_id, insecure_detector_id, item] if {
                        some data_risk in input.dataflow.risks
                        data_detector_id := data_risk.detector_id

                        data_type = data_risk.data_types[_]
                        data_location = data_type.locations[_]

                        some insecure_risk in input.dataflow.risks
                        insecure_detector_id := insecure_risk.detector_id
                        some insecure_location in insecure_risk.locations
                        data_location.filename == insecure_location.filename
                        data_location.parent.line_number == insecure_location.parent.line_number

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": data_location.filename,
                            "line_number": data_location.line_number,
                            "parent_line_number": data_location.parent.line_number,
                            "parent_content": data_location.parent.content
                        }
                    }

                    policy_failure contains item if {
                      insecure_http_with_data[["ruby_http_get_detection", "ruby_http_get_insecure", item]]
                    }

                    policy_failure contains item if {
                      insecure_http_with_data[["ruby_http_post_detection", "ruby_http_post_insecure", item]]
                    }
        insecure_smtp_processing_sensitive_data:
            query: |
                policy_failure = data.bearer.insecure_smtp.policy_failure
            id: detect_rails_insecure_smtp
            name: Insecure SMTP
            description: Communication using insecure SMTP in an application processing sensitive data. Verify that SMTP settings use OpenSSL or equivalent.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_smtp.rego
                  name: bearer.insecure_smtp
                  content: |
                    package bearer.insecure_smtp

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.content,
                        }
                    }
        jwt_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_rails_jwt
            name: JWT leaking
            description: JWT leaks detected. Avoid storing sensitive data in JWTs.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        logger_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_ruby_logger
            name: Logger leaking
            description: Logger leaks detected. Avoid passing sensitive data to loggers.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        sending_data_in_category_to_third_party:
            query: |
                policy_failure = data.bearer.third_party_data_category.policy_failure
            id: detect_ruby_third_party_data_send
            name: Third-party data category exposure
            description: Sending data in category to third party. Ensure data sent to third party is intended and secured.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/third_party_data_category.rego
                  name: bearer.third_party_data_category
                  content: |
                    package bearer.third_party_data_category

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        session_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_rails_session
            name: Session leaking
            description: Session leaks detected. Avoid storing sensitive data in the session.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        ssl_certificate_verification_disabled:
            query: |
                policy_failure = data.bearer.ssl_certificate_verification_disabled.policy_failure
            id: ssl_certificate_verification_disabled
            name: SSL certificate verification disabled
            description: SSL certificate verification is disabled in an application processing sensitive data. Enable SSL certificate verification.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/ssl_certificate_verification_disabled.rego
                  name: bearer.ssl_certificate_verification_disabled
                  content: |
                    package bearer.ssl_certificate_verification_disabled

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                      some data_type in input.dataflow.data_types

                      some detector in input.dataflow.risks
                      detector.detector_id == input.policy_id
                      location = detector.locations[_]

                      item = {
                        "category_groups": data.bearer.common.groups_for_datatype(data_type),
                        "severity": "medium",
                        "filename": location.filename,
                        "line_number": location.line_number,
                        "parent_line_number": location.parent.line_number,
                        "parent_content": location.parent.content
                      }
                    }
        weak_password_encryption:
            query: |
                policy_failure = data.bearer.weak_password_encryption.policy_failure
            id: detect_ruby_weak_encryption
            name: Weak password encryption
            description: Weak encryption or hashing library used to encrypt password. Use a stronger algorithm.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/encryption_common.rego
                  name: bearer.encryption_common
                  content: |-
                    package bearer.encryption_common

                    import future.keywords

                    rc4_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_rc4_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    blowfish_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_blowfish_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    openssl_pkey_rsa_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_openssl_pkey_rsa_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    openssl_pkey_dsa_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_openssl_pkey_dsa_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }
                - path: policies/weak_password_encryption.rego
                  name: bearer.weak_password_encryption
                  content: |
                    package bearer.weak_password_encryption

                    import data.bearer.common
                    import data.bearer.encryption_common

                    import future.keywords

                    password_uuid := "02bb0d3a-2c8c-4842-be1c-c057f0dccd63"

                    # openssl pkey rsa encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in ["ruby_openssl_pkey_rsa_method_call", "ruby_openssl_pkey_method_call"]

                        data_type = detector.data_types[_]
                        data_type.uuid == password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.openssl_pkey_rsa_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # openssl pkey dsa encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in ["ruby_openssl_pkey_dsa_method_call", "ruby_openssl_pkey_method_call"]

                        data_type = detector.data_types[_]
                        data_type.uuid == password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.openssl_pkey_dsa_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # blowfish encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "ruby_blowfish_method_call"

                        data_type = detector.data_types[_]
                        data_type.uuid == password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.blowfish_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # rc4 encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "encrypt_method_call"

                        data_type = detector.data_types[_]
                        data_type.uuid == password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.rc4_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]
                        data_type.uuid == password_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
    quiet: false
    skip-path: []
worker:
    existing-worker: ""
    file-size-max: 2000000
    files-to-batch: 1
    memory-max: 800000000
    timeout: 10m0s
    timeout-file-max: 30s
    timeout-file-min: 5s
    timeout-file-second-per-bytes: 10000
    timeout-worker-online: 1m0s
    workers: 1

