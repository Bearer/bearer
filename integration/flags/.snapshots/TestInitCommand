policy:
    only-policy: []
    skip-policy: []
report:
    format: ""
    output: ""
    report: policies
scan:
    context: ""
    custom_detector:
        detect_encrypted_ruby_class_properties:
            disabled: false
            type: verifier
            languages:
                - ruby
            param_parenting: true
            patterns:
                - pattern: |
                    class $CLASS_NAME < ApplicationRecord
                      encrypts <$ARGUMENT>
                    end
                  filters: []
            root_singularize: true
            root_lowercase: true
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_cookies:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    cookies[...] = $ANYTHING
                  filters: []
                - pattern: |
                    cookies.$METHOD_CHAIN[...] = $ANYTHING
                  filters:
                    - variable: METHOD_CHAIN
                      values:
                        - permanent
                        - encrypted
                        - signed
                        - permanent.encrypted
                        - permanent.signed
                        - permanent.encrypted.signed
                        - permanent.signed.encrypted
                        - encrypted.permanent
                        - encrypted.signed
                        - encrypted.permanent.signed
                        - encrypted.signed.permanent
                        - signed.encrypted
                        - signed.permanent
                        - signed.permanent.encrypted
                        - signed.encrypted.permanent
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_insecure_communication:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Rails.application.configure do
                      config.force_ssl = false
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: true
        detect_rails_insecure_ftp:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::FTP.new()
                  filters: []
                - pattern: |
                    Net::FTP.open()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        detect_rails_insecure_ftp_data:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::FTP.open do
                      $ANYTHING
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_insecure_smtp:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Rails.application.configure do
                      config.action_mailer.smtp_settings = {
                        openssl_verify_mode: OpenSSL::SSL::VERIFY_NONE
                      }
                    end
                  filters: []
                - pattern: |
                    Rails.application.configure do
                      config.action_mailer.smtp_settings = {
                        openssl_verify_mode: "none"
                      }
                    end
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: true
        detect_rails_jwt:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    JWT.encode(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_rails_session:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    session[...] = $ANYTHING
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_ruby_logger:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    logger.info(<$ARGUMENT>)
                  filters: []
                - pattern: |
                    Rails.logger.info(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_ruby_third_party_data_send:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Sentry::Breadcrumb.new(<$ARGUMENT>)
                  filters: []
                - pattern: |
                    Sentry.init do |config|
                      config.before_breadcrumb = lambda do |breadcrumb, hint|
                        breadcrumb.message = $ANYTHING
                        breadcrumb
                      end
                    end
                  filters: []
                - pattern: |
                    Sentry.set_user(<$ARGUMENT>)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_ruby_weak_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Digest::SHA1.hexidigest(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    Digest::MD5.hexdigest(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    OpenSSL::PKey::$LIBRARY.new($_, <$DATA_TYPE>)
                  filters:
                    - variable: LIBRARY
                      values: []
                      minimum: null
                      maximum: null
                      match_violation: false
                    - variable: ""
                      values:
                        - DSA
                        - RSA
                      minimum: null
                      maximum: null
                      match_violation: false
                - pattern: |
                    RC4.new(...).encrypt(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    OpenSSL::PKey::RSA.new($_, <$DATA_TYPE>)
                  filters: []
                - pattern: |
                    OpenSSL::PKey::RSA.new(...).$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - private_decrypt
                        - private_encrypt
                        - public_decrypt
                        - public_encrypt
                      minimum: null
                      maximum: null
                      match_violation: false
                - pattern: |
                    OpenSSL::PKey::DSA.new($_, <$DATA_TYPE>)
                  filters: []
                - pattern: |
                    OpenSSL::PKey::$LIBRARY.new(...).$METHOD($_, <$DATA_TYPE>)
                  filters:
                    - variable: $LIBRARY
                      values:
                        - DSA
                        - RSA
                      minimum: null
                      maximum: null
                      match_violation: false
                    - variable: METHOD
                      values:
                        - export
                        - to_pem
                        - to_s
                      minimum: null
                      maximum: null
                      match_violation: false
                - pattern: |
                    Crypt::Blowfish.new(...).encrypt_pair
                  filters: []
                - pattern: |
                    Crypt::Blowfish.new(...).$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - encrypt_pair
                        - encrypt_string
                        - encrypt_block
                        - decrypt_pair
                        - decrypt_string
                        - decrypt_block
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        detect_sql_create_public_table:
            disabled: false
            type: data_type
            languages:
                - sql
            param_parenting: true
            patterns:
                - pattern: |
                    CREATE TABLE public.$TABLE_NAME (
                      <$COLUMN>
                    )
                  filters: []
                - pattern: |
                    CREATE TABLE $TABLE_NAME (
                      <$COLUMN>
                    )
                  filters: []
            root_singularize: true
            root_lowercase: true
            metavars: {}
            stored: true
            detect_presence: false
            omit_parent: false
        encrypt_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - encrypt
                        - encrypt!
                        - decrypt
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        initialize_ruby_blowfish_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = Crypt::Blowfish.new(...)
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        initialize_ruby_openssl_pkey_dsa_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = OpenSSL::PKey::DSA.new()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        initialize_ruby_openssl_pkey_rsa_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = OpenSSL::PKey::RSA.new()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        initialize_ruby_rc4_encryption:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_ = RC4.new()
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ruby_blowfish_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - encrypt_pair
                        - encrypt_string
                        - encrypt_block
                        - decrypt_pair
                        - decrypt_string
                        - decrypt_block
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_file_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: true
            patterns:
                - pattern: |
                    CSV.generate { <$DATA_TYPE> }
                  filters: []
                - pattern: |
                    CSV.generate do
                      <$DATA_TYPE>
                    end
                  filters: []
                - pattern: |
                    $LIBRARY.open do
                      <$DATA_TYPE>
                    end
                  filters:
                    - variable: LIBRARY
                      values:
                        - CSV
                        - File
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_http_get_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    URI.encode_www_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    URI(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    $CLIENT.get(<$DATA_TYPE>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_http_get_insecure:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    URI(<$INSECURE_URL>)
                  filters: []
                - pattern: |
                    $CLIENT.get(<$INSECURE_URL>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ruby_http_post_detection:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    URI.encode_www_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    Net::HTTP.post_form(<$DATA_TYPE>)
                  filters: []
                - pattern: |
                    $CLIENT.post(<$DATA_TYPE>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_http_post_insecure:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::HTTP.post_form(<$INSECURE_URL>)
                  filters: []
                - pattern: |
                    $CLIENT.post(<$INSECURE_URL>)
                  filters:
                    - variable: CLIENT
                      values:
                        - Curl
                        - Excon
                        - Faraday
                        - HTTP
                        - HTTParty
                        - HTTPX
                        - RestClient
                        - Typhoeus
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ruby_openssl_pkey_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - export
                        - to_pem
                        - to_s
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_openssl_pkey_rsa_method_call:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    $_.$METHOD(<$DATA_TYPE>)
                  filters:
                    - variable: METHOD
                      values:
                        - private_decrypt
                        - private_encrypt
                        - public_decrypt
                        - public_encrypt
                      minimum: null
                      maximum: null
                      match_violation: false
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: false
            omit_parent: false
        ruby_password_length:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    class $ANYTHING < ApplicationRecord
                      validates :password, length: { minimum: $LENGTH }
                    end
                  filters:
                    - variable: LENGTH
                      values: []
                      minimum: 8
                      maximum: null
                      match_violation: true
                - pattern: |
                    class $ANYTHING < ApplicationRecord
                      device password_length: $MIN_LENGTH..$MAX_LENGTH
                    end
                  filters:
                    - variable: MAX_LENGTH
                      values: []
                      minimum: 35
                      maximum: null
                      match_violation: true
                    - variable: MIN_LENGTH
                      values: []
                      minimum: 8
                      maximum: null
                      match_violation: true
                - pattern: |
                    Device.setup do |config|
                      config.password_length = $LENGTH
                    end
                  filters:
                    - variable: LENGTH
                      values: []
                      minimum: 8
                      maximum: null
                      match_violation: true
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
        ssl_certificate_verification_disabled:
            disabled: false
            type: risk
            languages:
                - ruby
            param_parenting: false
            patterns:
                - pattern: |
                    Net::HTTP.start($_, $_, $_, :verify_mode => OpenSSL::SSL::VERIFY_NONE) do
                    end
                  filters: []
                - pattern: |
                    $_.verify_mode = OpenSSL::SSL::VERIFY_NONE
                  filters: []
            root_singularize: false
            root_lowercase: false
            metavars: {}
            stored: false
            detect_presence: true
            omit_parent: false
    debug: false
    disable-domain-resolution: true
    domain-resolution-timeout: 3s
    force: false
    internal-domains: []
    policies:
        application_level_encryption_missing:
            query: |
                policy_failure = data.bearer.application_level_encryption.policy_failure
            id: application_level_encryption_missing
            display_id: CR-021
            name: Force application-level encryption when processing sensitive data.
            description: Application-level encryption greatly reduces the risk of a data breach or data leak by making data unreadable. This policy checks if sensitive data types found in records are encrypted.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/application_level_encryption.rego
                  name: bearer.application_level_encryption
                  content: |-
                    package bearer.application_level_encryption

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        datatype = input.dataflow.data_types[_]
                        datatype.name != "Unique Identifier"

                        detector = datatype.detectors[_]
                        location = detector.locations[_]

                        location.stored

                        not location.encrypted


                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(datatype),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        cookie_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_rails_cookies
            display_id: CR-002
            name: Do not store sensitive data in cookies.
            description: Storing sensitive data in cookies can lead to a data breach. This policy looks for instances where sensitive data is stored in browser cookies.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        http_get_parameters:
            query: |
                policy_failure = data.bearer.http_get_parameters.policy_failure
            id: ruby_http_get_detection
            display_id: CR-015
            name: Do not send sensitive data as HTTP GET parameters.
            description: Sensitive data should never be sent as part of the query string in HTTP GET requests. This policy checks if sensitive data types are sent as GET parameters.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/http_get_parameters.rego
                  name: bearer.http_get_parameters
                  content: |-
                    package bearer.http_get_parameters

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_communication_processing_sensitive_data:
            query: |
                policy_failure = data.bearer.insecure_communication.policy_failure
            id: detect_rails_insecure_communication
            display_id: CR-012
            name: Force HTTPS access.
            description: When applications process sensitive data, they should default to always use SSL when available. This policy checks if force SSL is enabled at the application level.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_communication.rego
                  name: bearer.insecure_communication
                  content: |
                    package bearer.insecure_communication

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                          "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                          "severity": "medium",
                          "filename": location.filename,
                          "line_number": location.line_number,
                          "omit_parent": true,
                          "parent_line_number": location.parent.line_number,
                          "parent_content": location.parent.content,
                        }
                    }
        insecure_ftp_processing_sensitive_data:
            query: |
                policy_failure = data.bearer.insecure_ftp.policy_failure
            id: detect_rails_insecure_ftp
            display_id: CR-008
            name: Only communicate using SFTP connections.
            description: Communication with FTP servers should be done securely over SFTP in applications that process sensitive data. This policy checks if all FTP connections are made using SFTP.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_ftp.rego
                  name: bearer.insecure_ftp
                  content: |
                    package bearer.insecure_ftp

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_ftp_with_data_category:
            query: |
                policy_failure = data.bearer.insecure_ftp_with_data_category.policy_failure
            id: insecure_ftp_with_data_category
            display_id: CR-009
            name: Only send sensitive data using SFTP connections.
            description: Files containing sensitive data should only be sent via SFTP connections. This policy checks if files created using sensitive data are sent to over SFTP connections.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_ftp_with_data_category.rego
                  name: bearer.insecure_ftp_with_data_category
                  content: |
                    package bearer.insecure_ftp_with_data_category

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some risk in input.dataflow.risks
                        risk.detector_id == "detect_rails_insecure_ftp_data"

                        data_type = risk.data_types[_]
                        location = data_type.locations[_]

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_http_get:
            query: |
                policy_failure = data.bearer.insecure_http_get.policy_failure
            id: insecure_http_get
            display_id: CR-013
            name: Only communicate using HTTPS connections.
            description: Applications processing sensitive data should only connect using HTTPS connections. This policy checks that all HTTP connections use HTTPS.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_http_get.rego
                  name: bearer.insecure_http_get
                  content: |
                    package bearer.insecure_http_get

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == "ruby_http_get_insecure"

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        insecure_http_with_data_category:
            query: |
                policy_failure = data.bearer.insecure_http_with_data_category.policy_failure
            id: insecure_http_with_data_category
            display_id: CR-014
            name: Only send sensitive data through HTTPS connections.
            description: Sensitive data should only be sent through HTTPS. This policy checks that any transmissions over HTTP that contain sensitive data do so over HTTPS.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_http_with_data_category.rego
                  name: bearer.insecure_http_with_data_category
                  content: |
                    package bearer.insecure_http_with_data_category

                    import data.bearer.common

                    import future.keywords

                    insecure_http_with_data contains [data_detector_id, insecure_detector_id, item] if {
                        some data_risk in input.dataflow.risks
                        data_detector_id := data_risk.detector_id

                        data_type = data_risk.data_types[_]
                        data_location = data_type.locations[_]

                        some insecure_risk in input.dataflow.risks
                        insecure_detector_id := insecure_risk.detector_id
                        some insecure_location in insecure_risk.locations
                        data_location.filename == insecure_location.filename
                        data_location.parent.line_number == insecure_location.parent.line_number

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": data_location.filename,
                            "line_number": data_location.line_number,
                            "parent_line_number": data_location.parent.line_number,
                            "parent_content": data_location.parent.content
                        }
                    }

                    policy_failure contains item if {
                      insecure_http_with_data[["ruby_http_get_detection", "ruby_http_get_insecure", item]]
                    }

                    policy_failure contains item if {
                      insecure_http_with_data[["ruby_http_post_detection", "ruby_http_post_insecure", item]]
                    }
        insecure_smtp_processing_sensitive_data:
            query: |
                policy_failure = data.bearer.insecure_smtp.policy_failure
            id: detect_rails_insecure_smtp
            display_id: CR-010
            name: Only communicate with secure SMTP connections.
            description: Secure connections using SMTP help prevent unauthorized actors from viewing transmitted data. This policy checks if SMTP mailer settings are set to only allow secure connections.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/insecure_smtp.rego
                  name: bearer.insecure_smtp
                  content: |
                    package bearer.insecure_smtp

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.content,
                        }
                    }
        jwt_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_rails_jwt
            display_id: CR-004
            name: Do not store sensitive data in JWTs.
            description: JWTs are not a secure place to store sensitive data. This policy looks for any sensitive data types saved to a JWT.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        logger_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_ruby_logger
            display_id: CR-001
            name: Do not send sensitive data to loggers.
            description: Leaking sensitive data to loggers is a common cause of data leaks and can lead to data breaches. This policy looks for instances of sensitive data sent to loggers.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        password_length:
            query: |
                policy_breach = data.bearer.password_length.policy_breach
            id: ruby_password_length
            display_id: CR-019
            name: Enforce stronger password requirements.
            description: Minimum password length should be enforced any time password creation occurs. This policy checks if configurations and validations made for passwords include a minimum length of 8.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/password_length.rego
                  name: bearer.password_length
                  content: |
                    package bearer.password_length

                    import data.bearer.common

                    import future.keywords

                    policy_breach contains item if {
                        some data_type in input.dataflow.data_types

                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        location = detector.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatypes(input.dataflow.data_types),
                            "severity": "medium",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "omit_parent": true
                        }
                    }
        sending_data_in_category_to_third_party:
            query: |
                policy_failure = data.bearer.third_party_data_category.policy_failure
            id: detect_ruby_third_party_data_send
            display_id: CR-016
            name: Do not leak sensitive data to third-party loggers.
            description: 'Sensitive data should not be sent to third party logging libraries or services. This policy checks if sensitive data types are sent to third party loggers. Currently supports: Sentry. '
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/third_party_data_category.rego
                  name: bearer.third_party_data_category
                  content: |
                    package bearer.third_party_data_category

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        session_leaks:
            query: |
                policy_failure = data.bearer.leakage.policy_failure
            id: detect_rails_session
            display_id: CR-003
            name: Do not store sensitive data in session cookies.
            description: Sensitive data should not be stored in session cookies. This policy looks for any sensitive data stored within the session cookies.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/leakage.rego
                  name: bearer.leakage
                  content: |
                    package bearer.leakage

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        ssl_certificate_verification_disabled:
            query: |
                policy_failure = data.bearer.ssl_certificate_verification_disabled.policy_failure
            id: ssl_certificate_verification_disabled
            display_id: CR-011
            name: Enable SSL Certificate Verification.
            description: Applications processing sensitive data should use valid SSL certificates. This policy checks if SSL verification is enabled.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/ssl_certificate_verification_disabled.rego
                  name: bearer.ssl_certificate_verification_disabled
                  content: |
                    package bearer.ssl_certificate_verification_disabled

                    import data.bearer.common

                    import future.keywords

                    policy_failure contains item if {
                      some data_type in input.dataflow.data_types

                      some detector in input.dataflow.risks
                      detector.detector_id == input.policy_id
                      location = detector.locations[_]

                      item = {
                        "category_groups": data.bearer.common.groups_for_datatype(data_type),
                        "severity": "medium",
                        "filename": location.filename,
                        "line_number": location.line_number,
                        "parent_line_number": location.parent.line_number,
                        "parent_content": location.parent.content
                      }
                    }
        weak_encryption_library:
            query: |
                policy_failure = data.bearer.weak_encryption_library.policy_failure
            id: detect_ruby_weak_encryption_library
            display_id: CR-024
            name: Avoid weak encryption library.
            description: A weak encryption or hashing library can lead to data breaches and greater security risk. This policy checks for the use of weak encryption and hashing libraries or algorithms.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/encryption_common.rego
                  name: bearer.encryption_common
                  content: |-
                    package bearer.encryption_common

                    import future.keywords

                    password_uuid := "02bb0d3a-2c8c-4842-be1c-c057f0dccd63"

                    files_with_password_encryption_calls contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id in [
                        "ruby_openssl_pkey_rsa_method_call",
                        "ruby_openssl_pkey_method_call",
                        "ruby_blowfish_method_call",
                        "encrypt_method_call"
                      ]

                      data_type = detector.data_types[_]
                      data_type.uuid == password_uuid

                      location = detector.locations[_]

                      item := location.filename
                    }

                    rc4_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_rc4_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    blowfish_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_blowfish_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    openssl_pkey_rsa_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_openssl_pkey_rsa_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    openssl_pkey_dsa_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_openssl_pkey_dsa_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }
                - path: policies/weak_encryption_library.rego
                  name: bearer.weak_encryption_library
                  content: |
                    package bearer.weak_encryption_library

                    import data.bearer.common
                    import data.bearer.encryption_common

                    import future.keywords

                    password_uuid := "02bb0d3a-2c8c-4842-be1c-c057f0dccd63"

                    # openssl pkey rsa encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in ["ruby_openssl_pkey_rsa_method_call", "ruby_openssl_pkey_method_call"]

                        data_type = detector.data_types[_]
                        data_type.uuid != data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.openssl_pkey_rsa_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # openssl pkey dsa encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in ["ruby_openssl_pkey_dsa_method_call", "ruby_openssl_pkey_method_call"]

                        data_type = detector.data_types[_]
                        data_type.uuid != data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.openssl_pkey_dsa_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # blowfish encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "ruby_blowfish_method_call"

                        data_type = detector.data_types[_]
                        data_type.uuid != data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.blowfish_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # rc4 encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "encrypt_method_call"

                        data_type = detector.data_types[_]
                        data_type.uuid != data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.rc4_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in [
                          "initialize_ruby_rc4_encryption",
                          "initialize_ruby_blowfish_encryption",
                          "initialize_ruby_openssl_pkey_rsa_encryption",
                          "initialize_ruby_openssl_pkey_dsa_encryption",
                        ]

                        data_type = detector.data_types[_]
                        location = data_type.locations[_]
                        # NOT in a file with an encryption method call
                        not location in data.bearer.encryption_common.files_with_password_encryption_calls

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "detect_ruby_weak_encryption"

                        # NOT password data type
                        data_type = detector.data_types[_]
                        data_type.uuid != data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": "low",
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
        weak_password_encryption:
            query: |
                policy_failure = data.bearer.weak_password_encryption.policy_failure
            id: detect_ruby_weak_encryption
            display_id: CR-023
            name: Force strong password encryption.
            description: Using a weak encryption or hashing library to encrypt passwords can lead to security breaches and data leaks. This policy checks if weak encryption or hashing libraries are used to encrypt passwords.
            level: ""
            modules:
                - path: policies/common.rego
                  name: bearer.common
                  content: |
                    package bearer.common

                    import future.keywords

                    sensitive_data_group_uuid := "f6a0c071-5908-4420-bac2-bba28d41223e"
                    personal_data_group_uuid := "e1d3135b-3c0f-4b55-abce-19f27a26cbb3"

                    severity_of_datatype(data_type) := "critical" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == sensitive_data_group_uuid
                    }

                    severity_of_datatype(data_type) := "high" if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        some group in category.groups
                        group.uuid == personal_data_group_uuid

                        every group_1 in category.groups {
                            group_1.uuid != sensitive_data_group_uuid
                        }
                    }

                    groups_for_datatype(data_type) := x if {
                        some category in input.data_categories
                        category.uuid == data_type.category_uuid

                        x := {name | name := category.groups[_].name}
                    }

                    groups_for_datatypes(data_types) := groups if {
                        groups := {name | name := groups_for_datatype(data_types[_])[_]}
                    }
                - path: policies/encryption_common.rego
                  name: bearer.encryption_common
                  content: |-
                    package bearer.encryption_common

                    import future.keywords

                    password_uuid := "02bb0d3a-2c8c-4842-be1c-c057f0dccd63"

                    files_with_password_encryption_calls contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id in [
                        "ruby_openssl_pkey_rsa_method_call",
                        "ruby_openssl_pkey_method_call",
                        "ruby_blowfish_method_call",
                        "encrypt_method_call"
                      ]

                      data_type = detector.data_types[_]
                      data_type.uuid == password_uuid

                      location = detector.locations[_]

                      item := location.filename
                    }

                    rc4_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_rc4_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    blowfish_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_blowfish_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    openssl_pkey_rsa_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_openssl_pkey_rsa_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }

                    openssl_pkey_dsa_files contains item if {
                      some detector in input.dataflow.risks
                      detector.detector_id == "initialize_ruby_openssl_pkey_dsa_encryption"

                      location = detector.locations[_]

                      item := location.filename
                    }
                - path: policies/weak_password_encryption.rego
                  name: bearer.weak_password_encryption
                  content: |
                    package bearer.weak_password_encryption

                    import data.bearer.common
                    import data.bearer.encryption_common

                    import future.keywords

                    # openssl pkey rsa encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in ["ruby_openssl_pkey_rsa_method_call", "ruby_openssl_pkey_method_call"]

                        data_type = detector.data_types[_]
                        data_type.uuid == data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.openssl_pkey_rsa_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # openssl pkey dsa encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id in ["ruby_openssl_pkey_dsa_method_call", "ruby_openssl_pkey_method_call"]

                        data_type = detector.data_types[_]
                        data_type.uuid == data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.openssl_pkey_dsa_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # blowfish encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "ruby_blowfish_method_call"

                        data_type = detector.data_types[_]
                        data_type.uuid == data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.blowfish_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    # rc4 encryption
                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == "encrypt_method_call"

                        data_type = detector.data_types[_]
                        data_type.uuid == data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        location.filename in data.bearer.encryption_common.rc4_files

                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }

                    policy_failure contains item if {
                        some detector in input.dataflow.risks
                        detector.detector_id == input.policy_id

                        data_type = detector.data_types[_]
                        data_type.uuid == data.bearer.encryption_common.password_uuid

                        location = data_type.locations[_]
                        item := {
                            "category_groups": data.bearer.common.groups_for_datatype(data_type),
                            "severity": data.bearer.common.severity_of_datatype(data_type),
                            "filename": location.filename,
                            "line_number": location.line_number,
                            "parent_line_number": location.parent.line_number,
                            "parent_content": location.parent.content
                        }
                    }
    quiet: false
    skip-path: []
worker:
    existing-worker: ""
    file-size-max: 2000000
    files-to-batch: 1
    memory-max: 800000000
    timeout: 10m0s
    timeout-file-max: 30s
    timeout-file-min: 5s
    timeout-file-second-per-bytes: 10000
    timeout-worker-online: 1m0s
    workers: 1

